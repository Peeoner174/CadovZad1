Этапы проектирования и реализации фичи определения наличия сети интернет для приложения EShop.

Задача поставлена в контексте - проверить соответствие указанному user flow, исправить баги. Сразу - баги были, но они имели неявные шаги воспроизведения. 

После исследования проблемы я пришел к выводу, что код ReachabilityManager`a нужно полностью переписать. Потому как  былf выявлена проблема дублирование функционала.
Так как я имею представление о функциональности сторонних библиотек, которые использую, я знал, что у Alamofire есть функционал проверки подключения к сети, а swiftEntryKit позволяет без проблем создать необходимое диалоговое окно 
Поэтому pod`ы ReachabilitySwift, NotificationBannerSwift были удалены. 

Первым делом я сформулировал желаемый функционал через протоколы
1. NetworkStatusListener - протокол делегат. Его реализуют сущности, которые хотят реагировать на изменение статуса сети.  Паттерн Observer 
2. NetworkStatusMulticast - протокол декоратор. Методы для взаимодействия с подписчиками статуса сети. Улучшение организации данных класса. Выразительность с помощью естественных для языка(swift) конструкций вместо комментариев 
3. NetworkStatus - протокол декоратор. Сам не производит никаких действий, только возвращает статус. Частично можно отнести к паттерну State

Для удобства работы со слушателями был создан класс MulticastDelegate - класс реализует паттерн “команда” 

Степень соответствия SOLID 
Single responsibility - следует. Весь функционал четко определен. Вся дополнительная логика отделена либо протоколами, либо отдельными классами
Open closed Principe - поддерживается с помощью протоколов - декораторов
Барбары лисков -  модификаторы доступа, протоколы
Inversion control principe - поддерживается с помощью протоколов - делегатов
Dipendency injection principe - опять же обратите внимание на класс MulticastDelegate, протокол NetworkStatusListener

В итоге удалось достичь: 
Исправлены баги
Уменьшена кодовая база 

Проблемы, ошибки
В целях следования принципу  Open closed  из Solid имело смысл синглтон создать как тип, который реализует конкретный протокол. 
Вместо     
static let shared = ReachabilityManager()
Написать к примеру 
static let shared: NetworkTracker = ReachabilityManager()
Это было сделано Леонидом.

Первая реализация Женя 
Вторая Паша
Третья рефактор второй от Лени

Комментарии Лени: 
“””
- ты там описал протокол, реализовал его в менеджере и на этом все. Либо протокол вообще не нужен тогда, потому что ты все равно будешь обращаться к shared как к интерфейсу класса, а не описанного тобой протокола, либо ты закрываешь класс протоколом ( let shared: ReachabilityProtocol = ReachabilityManager() )

- мне проще через массив weak работать было, потому что то что ты сделал (через словарь вроде) было неудобно дебажить. Мне кажется у меня просто более явно, в остальном различий нет, можно было оставить как ты сделал
”””




