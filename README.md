Задача: Создать видеоплеер для приложения талан.
Требования заказчика:
1. Видео проигрывается в ленте collectionView 
2. Видео должно автоматически ставиться на паузу, воспроизводиться, перематываться во время взаимодействия пользователя с приложением 
3. Для экономии трафика пользователя и улучшения впечатления видео должно кешироваться
4. Должна быть возможность развернуть видео на весь экран, при этом воспроизведение должно продолжиться с той же точки
5. Возможность задать зацыкливаниe для видео в ячейке collectionView, с целью экономии трафика пользователя. (Например внутри ячейки проигрывать только первые пятнадцать секунд видео)
6. Возможность задать для preview и fullscreen разные видосы. 
Требования, которые я сформулировал к реализации фичи, после изучения требований заказчика:
1. Добиться гибкости реализации
CollectionView, в котором должно проигрываться видео может содержать картинки. Видео потребляет много трафика, интернет не всегда работает идеально, поэтому вполне вероятно, что в будущем может быть поставлена задача - во время подгрузки видео показывать картинку - плейсхолдер (либо спинер, либо все что угодно вообще). Картинка, например, может содержать дополнительную информацию, корреллирующую с самим видео. 
Подумав над решением этой проблемы я решил добавлять видео на вью как Layer
2. В одном collectionView может быть несколько видео, каждое должно помнить свое состояние 
Крепко разобраться с работой и возможностями NSCashe, хорошо продумать структуру видео контейнера
3. Сложные зависимости стейтов видео.
При переходе из превью в полноэкранный режим должна сохраняться информация о состоянии превью, так как четко может быть определен отрезок который может проигрываться в превью режиме.
4. Удобная реализация автовоспроизведения видео
В сущности, которая показывает видео не должно быть логики автовоспроизведения. Она будет захламлять VIPER - модуль. В презенторе модуля вся настройка автовоспроизведением должна производиться через несколько кнопок управления. Программист, работающий непосредственно с модулем, не должен заботиться о реализации автовоспроизведения.

 Реализацию фичи я начинаю с прописывания списка протоков, так как их можно четко определить уже на этом этапе, после разделения UserStory на подзадачи
По сути у нас всегда будут два вида сущностей:
1. Сущность, которая будет воспроизводить видео на себе 
Паттерны - фасад, компоновщик, фабричный метод
2. Сущность, которая будет управлять воспроизведением видео
Паттерны - фасад, частично State, частично команда.

Далее, для второй сущности я определяю дефолтные реализации. Стратегия

Видео контейнер выражаю как сочетание модели видео и реализации State(превращения в отдельные сущности огромных стейт машин, основаных на операторе switch). Цель модели - хранить исчерпывающую модель видео. State-машины - исчерпывающие инструменты управления воспроизведения видео - модели.
Также VideoContainer реализует паттерн прототип. Цель - реализация экономии трафика, управление сложным жизненным циклом видео.(добавление в Кеш, извлечение из кеша, переключение из preview в fullscreen и обратно и т.д) Паттерн легковес.

Сущность NITVideoPlayerManager 
Четко гарантирует что в режиме воспроизведения может находится одновременно только одно видео.
Реализует паттерн Observer - управляет воспроизведением видео на основе команд поступающих от сущностей, реализующих протокол NITAutoPlayVideoLayerContainerDelegate
Играет роль конфигуратора - Паттерн фасад. 
Управляет видео с каким ключом(ключом в данном случае является url видео) должно воспроизводиться на конкретной ячейке - частично паттерн Цепочка обязанностей

Соответствие принципам SOLID. 
Single responsibility - частично (об обязательности следования принципам SOLID читайте в README файле корневой папки)
Open Closed - да, так как все взаимодействие производиться через протоколы и ограниченный небольшой набор конфигурирующих переменных. При этом реализация благоприятна для добавления нового функционала или удаления старого
Лисков - да, с помощью модификаторов доступа, грамотного формирования “фасада”(паттерн) классов
Inversion control - Опять же Фасад
Dipendency injection principe - да, активно используются делегаты. 

Можно ли назвать реализацию “идеальной” - да



